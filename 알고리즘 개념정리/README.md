# 알고리즘 개념정리
> 백준은 파이썬, 프로그래머스는 js로 풀었습니다.
- [최대공약수, 최소공배수 알고리즘](#최대공약수-최소공배수-알고리즘 "최대공약수, 최소공배수 알고리즘")
- [소수 찾기 알고리즘](#소수-찾기 "소수 찾기 알고리즘")


<br>
<br>
<br>


# 최대공약수, 최소공배수 알고리즘
## 최대공약수(Greatest Common Divisor, GCD)

최대공약수를 계산하는 대표적인 알고리즘으로는 **유클레드 호제법**이 있다.

유클리드 호제법은 두 수 a, b가 있을 때, a를 b로 나눈 나머지를 r이라고 한다면, a와 b의 최대공약수는 b와 r의 최대공약수와 같다는 원리를 이용한다. 이를 반복하여 나머지가 0이 될 때까지 계산하면 최대공약수를 구할 수 있다.

```
function gcd(a, b) {
  return b ? gcd(b, a % b) : a
}
```

<br>

## 최소공배수(Least Common Multiple, LCM)

두 수의 최대공약수를 구한 후, 곱한 값을 최대공약수로 나누면 최소공배수를 구할 수 있다.

```
function lcm(a, b) {
  return a * b / gcd(a, b)
}
```
<br>

# 소수 찾기
## 소수(Prime Number)
자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는, 1보다 큰 자연수이다.

<br>

## 제곱근
N의 약수는 무조건 sqrt(N)의 범위에 존재한다. <br>
만약 N이 12라 할때, 12의 제곱근은 약 3.46이다. <br>
12의 약수는 1, 2, 3, 4, 6, 12 이다. <br>
여기서 1과 12를 제외했을 때 이는 2 * 6, 3 * 4, 4 * 3, 6 * 2의 결과이다.

이들의 관계는 결국 N의 제곱근까지 향하게 되면 이후 몫과 나누는 값이 반대로 바뀌게만 되는 상황이다.

따라서 N의 제곱근까지 나누어 떨어지는지 여부를 조사하면 더 빠르게 소수판별을 할 수 있다. 

<br>

## 에라토스테네스의 체
고대 그리스의 수학자 에라토스테네스가 만들어 낸 소수를 찾는 방법.<br> 이 방법은 마치 체로 치듯이 수를 걸러낸다고 하여 '에라토스테네스의 체'라고 부른다.

1. 2부터 차례로 모든 자연수를 나열한다.
2. 아직 체크되지 않은 수 중에서 가장 작은 수를 찾는다. 이 수는 소수이다.
3. 이제 이 소수의 배수를 모두 체크한다. 이때, 이미 체크된 수는 건너뛰고, 아직 체크되지 않은 수만 체크한다.
4. 2~3 과정을 반복한다.

<br>
따라서 이 방법들을 이용하여 코드를 구현하면 다음과 같다.

<br>

프로그래머스 ['소수 찾기'](https://school.programmers.co.kr/learn/courses/30/lessons/12921) 문제

> **문제 설명**
<br>1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.
<br>소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
(1은 소수가 아닙니다.)
<br> *n은 2이상 1000000이하의 자연수입니다.*


```
function solution(n) {
  let cnt = 1 // 2는 이미 소수이므로 cnt에 추가해줌
  for (let i = 3; i <= n; i += 2) {
    if (isPrime(i)) cnt++
  }
  return cnt;
}

// 소수인지 판별하는 함수
function isPrime(num) {
  if (num % 2 === 0) return false; // 2의 배수면 무조건 false 반환

  const sqrt = Math.floor(Math.sqrt(num));
  for (let i = 3; i <= sqrt; i += 2) {
    if (num % i === 0) return false;
  }
  return true;
}
```

